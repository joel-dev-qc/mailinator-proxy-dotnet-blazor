@using MailinatorProxy.Shared.Dtos.Mails
@using MailinatorProxy.Web.ApiClients
@using MailinatorProxy.Web.Extensions
@using MailinatorProxy.Web.States
@using Microsoft.Extensions.Localization
@inject IMalinatorApiClient MailinatorApiClient
@inject InboxFavoriteState InboxFavoriteState
@inject MailReadState MailReadStateService
@inject ISnackbar Snackbar
@inject IStringLocalizer<InboxList> L
@inject ILogger<InboxList> Logger
@inject InboxListState InboxListState

<style>
    tr.unread-row td,
    tr.unread-row td * {
        font-weight: bold !important;
    }
</style>

<DynamicDataFilter @ref="_dynamicDataFilter" Model="_inboxFilters" OnFiltersChanged="ReloadData">
    <MudGrid Spacing="2">
        <MudItem lg="4" md="5" sm="6" xs="12">
            <MudTextField @bind-Value="_inboxFilters.Inbox"
                          For="() => _inboxFilters.Inbox"
                          T="string?"
                          Label="@L["Inbox_Label"]"
                          Margin="Margin.Dense"
                          Variant="Variant.Outlined"
                          @onfocusout="@(() => _inboxFilters.Inbox = GetCurrentInbox())"
                          AdornmentIcon="@Icons.Material.Filled.Undo"
                          Adornment="@(_inboxFilters.Inbox != "*" ? Adornment.End : Adornment.None)"
                          AdornmentAriaLabel="@L["AllInboxes_AriaLabel"]"
                          OnAdornmentClick="@(() => OnInboxToFiltersChanged("*"))" />
        </MudItem>

        <MudItem lg="12" md="12" sm="12" xs="12">
            <div class="d-flex flex-wrap gap-2 py-4">
                @foreach (var favorite in _mailToFavorites)
                {
                    <MudChip T="string"
                             Size="Size.Medium"
                             OnClose="@(() => InboxFavoriteState.ToggleFavoriteAsync(Domain, favorite))"
                             CloseIcon="@Icons.Material.Filled.Close"
                             Icon="@Icons.Material.Filled.Star"
                             OnClick="() => OnInboxToFiltersChanged(favorite)">@favorite</MudChip>
                }
            </div>
        </MudItem>
    </MudGrid>
</DynamicDataFilter>
<AutoRefreshWrapper @ref="_autoRefresh" RefreshIntervalSeconds="5" OnRefresh="CheckForNewMessages">
    <MudPaper>
        <div class="pa-4">
            <MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                    <MudTooltip Text="@L["Inbox_RefreshTooltip"]">
                        <MudIconButton Icon="@Icons.Material.Filled.Refresh" OnClick="_autoRefresh.RefreshAsync" />
                    </MudTooltip>
                    <MudTooltip Text="@(_autoRefresh.IsEnabled ? L["Inbox_AutoRefreshPauseTooltip"] : L["Inbox_AutoRefreshStartTooltip"])">
                        <MudIconButton Icon="@(_autoRefresh.IsEnabled ? Icons.Material.Filled.Pause : Icons.Material.Filled.PlayArrow)"
                                       OnClick="_autoRefresh.Toggle" />
                    </MudTooltip>
                    @_autoRefresh.Status
                </MudStack>

                <MudSpacer/>
                <MudText Typo="Typo.body2">@_domainState.Messages.Count message(s)</MudText>
            </MudStack>
        </div>


        <MudTable Items="_domainState.Messages"
                  Hover="true"
                  @ref="_table"
                  Loading="@_isLoading"
                  LoadingProgressColor="Color.Info"
                  Elevation="0"
                  T="MessageDto"
                  RowClassFunc="GetRowClass"
                  OnRowClick="OnSelectMessageEvent">


            <RowTemplate>
                <MudTd Class="align-content-start"><MudText Typo="Typo.body1" Class="bold">@context.From</MudText></MudTd>
                <MudTd>
                    <div class="d-flex flex-wrap">
                        <MailToLabel FullEmail="@($"{context.To}@{context.Domain}")" Identifier="@context.To"
                                     Size="Size.Small" Class="mr-2" Style="margin-top:-1px;"/>
                        <MudText Typo="Typo.body1" Class="bold">@context.Subject</MudText>
                    </div>
                </MudTd>
                <MudTd Class="align-content-start">
                    <MudText Typo="Typo.body1" Class="bold">
                        <RelativeDate DisplayTime="true" Date="@context.Time.ToDateTime()"/>
                    </MudText>
                </MudTd>
                <MudTd Class="align-content-start">
                    <div class="d-flex justify-end gap-2">
                        <SetMailFavorite Domain="@context.Domain" Identifier="@context.To" Size="Size.Small"/>
                        <MudTooltip Text="Delete">
                            <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                           Color="Color.Default"
                                           Size="Size.Small"
                                           OnClick="() => DeleteMessage(context)"/>
                        </MudTooltip>
                    </div>
                </MudTd>
            </RowTemplate>

        </MudTable>

        <div class="d-flex justify-center my-4 pa-4">
            @if (_domainState.HasMoreData)
            {
                <MudButton Disabled="_isLoading" OnClick="LoadMoreItems" StartIcon="@Icons.Material.Filled.MoreHoriz">
                    @(_isLoading ? @L["Loading"] : @L["LoadMore"])
                </MudButton>
            }
            else if (_domainState.Messages.Count == 0)
            {
                <MudText Typo="Typo.caption">@L["NoMessages"]</MudText>
            }
            else
            {
                <MudText Typo="Typo.caption">@L["NoMoreMessages"]</MudText>
            }
        </div>
    </MudPaper>
</AutoRefreshWrapper>


@code {
    [Parameter] public string Domain { get; set; } = string.Empty;
    [Parameter] public EventCallback<string> OnSelectMessage { get; set; }
    [Parameter] public EventCallback<MessageDto> OnDeleteMessage { get; set; }

    private const int RefreshWindowSize = 2;

    private MudTable<MessageDto> _table;
    private DynamicDataFilter _dynamicDataFilter;
    private AutoRefreshWrapper _autoRefresh;
    private List<string> _mailToFavorites = [];
    private InboxListState.DomainInboxState _domainState;

    private int _pageSize = 2;
    private bool _isLoading = false;
    private SemaphoreSlim _operationLock = new(1, 1);

    private InboxFilters _inboxFilters = new();

    protected override async Task OnInitializedAsync()
    {
        _domainState = InboxListState.GetOrCreateDomainState(Domain);
        _inboxFilters.Inbox = _domainState.CurrentInbox;

        await InboxFavoriteState.InitializeAsync(Domain);
        RefreshMailToFavorites();
        InboxFavoriteState.OnChanged += HandleOnFavoriteChanged;
        await ReloadData();
    }

    private async Task CheckForNewMessages()
    {

        if (_isLoading) return;

        try
        {
            _isLoading = true;
            StateHasChanged();

            var latestMessages = await LoadInboxAsync(0, RefreshWindowSize);

            // Prevent duplicate messages by checking against current messages
            var currentIds = new HashSet<string>(_domainState.Messages.Select(m => m.Id));
            var newMessages = latestMessages
                .Where(m => !currentIds.Contains(m.Id))
                .ToList();

            if (newMessages.Count > 0)
            {
                foreach (var msg in newMessages)
                {
                    _domainState.ReadStates[msg.Id] = await MailReadStateService.IsReadAsync(Domain, msg.Id);
                }

                _domainState.Messages.InsertRange(0, newMessages);

                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error checking for new messages.");
            Snackbar.Add(L["Inbox_LoadError"], Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task ReloadData()
    {
        if (_isLoading) return;

        await _operationLock.WaitAsync();
        try
        {
            _isLoading = true;
            StateHasChanged();

            var newMessages = await LoadInboxAsync(0, _pageSize);
            _domainState.Messages = DeduplicateAndAppend(newMessages, _domainState.Messages);
            _domainState.CurrentOffset = newMessages.Count;
            _domainState.HasMoreData = newMessages.Count >= _pageSize;
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
            _operationLock.Release();
        }
    }

    private async Task LoadMoreItems()
    {
        if (_isLoading || !_domainState.HasMoreData) return;

        await _operationLock.WaitAsync();
        try
        {
            _isLoading = true;
            StateHasChanged();

            var moreMessages = await LoadInboxAsync(_domainState.CurrentOffset, _pageSize);
            _domainState.Messages = DeduplicateAndAppend(_domainState.Messages, moreMessages);

            _domainState.CurrentOffset = _domainState.Messages.Count;
            _domainState.HasMoreData = moreMessages.Count >= _pageSize;

            // Ensure that the auto-refresh countdown is reset after loading more items. To prevent it from triggering immediately after loading.
            _autoRefresh.ResetCountdown();
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
            _operationLock.Release();
        }
    }

    private async Task<List<MessageDto>> LoadInboxAsync(int skip, int limit)
    {
        try
        {
            var result = await MailinatorApiClient.GetMailInboxAsync(Domain, GetCurrentInbox(), skip: skip, limit: limit);
            foreach (var msg in result.Messages)
            {
                _domainState.ReadStates[msg.Id] = await MailReadStateService.IsReadAsync(Domain, msg.Id);
            }
            return result.Messages;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading inbox");
            Snackbar.Add(L["Inbox_LoadError"], Severity.Error);
            return new();
        }
    }

    private string GetRowClass(MessageDto msg, int index)
    {
        return _domainState.ReadStates.TryGetValue(msg.Id, out var read) && !read ? "unread-row cursor-pointer" : "cursor-pointer";
    }

    private async Task DeleteMessage(MessageDto msg)
    {
        if (OnDeleteMessage.HasDelegate)
        {
            await OnDeleteMessage.InvokeAsync(msg);
            await ReloadData();
            Snackbar.Add(L["MessageDeleted_Info"], Severity.Info);
        }
    }

    private async Task OnSelectMessageEvent(TableRowClickEventArgs<MessageDto> selected)
    {
        if (OnSelectMessage.HasDelegate)
        {
            await OnSelectMessage.InvokeAsync(selected.Item.Id);
        }
    }

    private void OnInboxToFiltersChanged(string inbox)
    {
        _inboxFilters.Inbox = inbox;
        _dynamicDataFilter.NotifyChanged(nameof(InboxFilters.Inbox));
    }

    private static List<MessageDto> DeduplicateAndAppend(List<MessageDto> source, List<MessageDto> toAppend)
    {
        var existingIds = source.Select(m => m.Id).ToHashSet();
        var newItems = toAppend.Where(m => !existingIds.Contains(m.Id)).ToList();
        source.AddRange(newItems);
        return source.OrderByDescending(m => m.Time).ToList();
    }

    private string GetCurrentInbox() => string.IsNullOrWhiteSpace(_inboxFilters.Inbox) ? "*" : _inboxFilters.Inbox;

    private void RefreshMailToFavorites() => _mailToFavorites = InboxFavoriteState.GetAllFavorites(Domain).ToList();
    private void HandleOnFavoriteChanged(string _) => InvokeAsync(StateHasChanged);

    private class InboxFilters { public string Inbox { get; set; } = "*"; }

    public void Dispose()
    {
        InboxFavoriteState.OnChanged -= HandleOnFavoriteChanged;
        _operationLock.Dispose();
    }
}
